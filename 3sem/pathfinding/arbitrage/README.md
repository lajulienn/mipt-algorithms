#Условие задачи
Необходимо написать торгового советника для поиска арбитража.
Арбитраж - это торговля по цепочке различных валют в надежде заработать на небольших различиях в коэффициентах. Например, есть следующие курсы валют:
GBP/USD: 0.67
RUB/GBP: 78.66
USD/RUB: 0.02
Имея 1$ и совершив цикл USD->GBP->RUB->USD, получим 1.054$. Таким образом заработав 5.4

##Формат ввода
Первая строка содержит число N – количество возможных валют (определяет размер таблицы котировок). 
Далее следует построчное представление таблицы. Диагональные элементы (i, i) пропущены (подразумевается, что курс валюты к себе же 1.0). 
В элементе таблицы (i, j) содержится обменный курс i->j. 
Если обмен в данном направлении не производится, то -1.

##Формат вывода
Выведите YES, если арбитраж есть, и NO, иначе.

#Алгоритм работы
Решение данной задачи основано на алгоритме Беллмана-Форда. 
Он позволяет нам находить кратчайшие пути из заданной вершины до всех остальных, а также находить циклы отрицательного веса. 

Заметим, что алгоритм можно модифицировать так, чтобы он позволял решить задачу поиска арбитража.
Наличие арбитража из условия - это, по сути, наличие в исходном графе цикла бесконечного веса. 
За вес ребра `(u, v)` в данном случае выступает курс обмена `u -> v`. 
При этом, чтобы найти вес пути через вершины `v_1,...,v_n`, нужно перемножить их веса: `w(v_1) * ... * w(v_n)`. 
Важное отличие от исходного алгоритма в том, что при перевоначальной инициализации расстояний до вершин мы присваиваем для всех v, кроме стартовой `d(v) = -∞ = FLT_MIN`. 
Для стартовой вершины `d(v_0) = 1`. 

Все вышеперечисленное реализовано в функции `FindCycle()`.
В main() мы считываем из входного потока таблицу котировок с помощью `ScanTable()`. 
Затем для каждой валюты запускаем наш алгоритм, чтобы проверить наличие арбитража начинающегося с данной валюты. 
Для удобства храним таблицу курсов валют в виде `vector<ExchangeRate>`, где `ExchangeRate` - структура с полями `from`, `to` - валюты обмена, `rate` - курс.

Затраты времени: алгоритм поиска цикла работает за `O(VE)`, т.к. мы проходим по всем вершинам, для них по всем ребрам. 
Мы запускаем алгоритм для каждой из n валют, поэтому итоговая сложность `O(V^2 * E)`.
Память: храним `n * n` ребер => `O(n^2)`.
